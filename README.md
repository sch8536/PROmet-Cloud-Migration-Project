# ☁️  AWS 클라우드 3계층 아키텍처 프로젝트

Cloud Bootcamp 동안 우리 팀이 수행한 온프레미스 프로젝트에서 AWS 클라우드 마이그레이션

![image](https://user-images.githubusercontent.com/76054852/230936330-b24d41ad-f4ea-459e-882b-bea13521a3df.png)

> 기술 문서 및 프리젠테이션 pdf 파일이 포함되어 있습니다.

🌐 [PROmet](https://github.com/sch8536/PROmet-Website) - Django 프레임워크를 사용하여 만든 PROmet 웹사이트

👨‍💻 [Infrastructure as Code](https://github.com/sch8536/AWS-3-tier-Terraform) -  AWS 인프라 Terraform 코드 repository

🖥️ [On-Premise](https://github.com/sch8536/PROmet-On-premise) - 온프레미스 버전

## 💡 목표

이번 AWS 클라우드 마이그레이션 프로젝트의 목표는 늘어난 트래픽과 공공 수요를 해결하는 것이었습니다. PROmet은 클라우드 마이그레이션 계획, 구현 및 지속적인 관리 서비스를 제공하는 PROcloud와 파트너 관계를 맺었습니다. PROcloud는 클라우드로 마이그레이션하여 PROmet의 웹 서비스를 지원했습니다. PROmet의 확장성, 안정성을 개선하고 비용을 절감했습니다.

## ⛏️ 목표 및 디자인
기존에는 온프레미스에서 서비스를 운영했지만 마이그레이션을 시작하기 위해 리호스팅 방식을 선택했습니다. 물론 마이그레이션하기 전에 먼저 인프라를 프로비저닝했습니다. 새 VPC를 생성하고 두 가용 영역 간의 라우팅 테이블을 사용하여 이에 따라 라우팅을 설정했습니다. 퍼블릭 서브넷을 인터넷 게이트웨이에 연결하고 프라이빗 서브넷에 NAT 게이트웨이를 추가했습니다. 퍼블릭 서브넷에 하나의 배스천 호스트 EC2 인스턴스를 생성하고 프라이빗 서브넷에서 Django 애플리케이션을 호스팅하는 EC2 인스턴스를 추가했습니다. 또한 프라이빗 서브넷에 RDS를 설정했습니다. 사용자가 두 가용 영역 간에 상호 작용하고 로드 밸런싱을 수행할 수 있도록 퍼블릭 서브넷에 애플리케이션 로드 밸런서를 설정했습니다. Django 애플리케이션을 EC2 인스턴스에 배포하고 Auto Scaling 그룹을 구현하여 두 번째 가용 영역에 복제된 EC2 인스턴스를 생성했습니다. 또한 다른 가용성 영역에서 기본 RDS 및 읽기 전용 복제 RDS를 구현했습니다. Django 앱의 모든 EC2 인스턴스에 EFS를 탑재했습니다. 사용자가 도메인 이름을 사용하여 웹 앱에 액세스할 수 있도록 Route53 호스팅 영역을 추가했습니다. 또한 HTTPS 연결을 위해 AWS ACM에서 SSL/TLS 인증서를 얻었습니다. SNS를 통해 이메일 알림을 보내기 위해 Cloudwatch를 통해 지표 수집을 설정했습니다. 또한 Grafana를 도입하여 Cloudwatch 지표와 통합하고 Grafana 대시보드에서 실시간 EC2 인스턴스 모니터링을 설정했습니다. 개발자가 Github 리포지토리에 코드를 푸시하면 프로덕션에 자동으로 코드를 적용하도록 Jenkins CI/CD를 구현했습니다.


## 📝 결론

이 프로젝트를 진행하는 동안 퍼블릭 클라우드의 네트워킹, EC2 인스턴스에 애플리케이션 배포, RDS를 사용한 데이터베이스 관리, ALB/NLB를 사용한 로드 밸런싱, EFS를 사용한 파일 스토리지 관리, Auto Scaling 그룹 구현, Route53을 사용한 DNS 관리 및 Jenkins 및 Github webhook으로 CI/CD 구현. 라우팅 테이블을 사용하여 두 개의 서로 다른 가용 영역을 라우팅하는 데 약간의 어려움이 있었지만 Google, AWS 설명서 및 YouTube를 사용하여 해결할 수 있었습니다. EFS 마운트는 생각보다 조금 오래 걸렸지만 설명서를 참고해서 빠르게 해결할 수 있었습니다. 가장 어려웠던 부분은 Jenkins CI/CD 파이프라인이었습니다. 이 기술은 저에게 매우 생소한 기술이었기 때문에 프로젝트에 적용하기 전에 며칠 동안 연구했습니다. Github webhook에 의해 트리거될 때 작업자 노드에서 Jenkins 작업을 빌드하도록 구성했습니다. 문제는 퍼블릭 클라우드 플레인 내에서 마스터 Jenkins 노드와 워커 노드를 연결하는 데 필요한 키를 확인하는 전략이 필요하다는 점이었다. 이 문제는 단순히 노드를 작업자 노드에 SSH로 설정하여 해결되었습니다. 또 다른 문제는 Terraform의 작동 방식을 이해하는 것이었습니다. 코드를 사용하여 인프라와 리소스를 프로비저닝하는 방법만 알았을 뿐 실제로 어떻게 작동하는지 몰랐습니다. 그래서 몇 가지 테스트를 실행하여 '.tf' 파일이 어떻게 작동하는지 이해하기 위해 연구를 수행했습니다. 모듈이 어떻게 동작하는지 살펴보기도 했지만, 이번 프로젝트에서는 인프라 구성을 위한 리소스 블록만 구현했습니다. 'terraform 계획' 부분에서 많은 오류가 발생했고, Terraform 문서를 통해 해결 방법을 찾아야 했습니다.
